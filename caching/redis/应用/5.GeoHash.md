# **GeoHash**

- Redis 在 3.2 版本以后增加了**地理位置 ```GEO``` 模块**，意味着我们可以使用 Redis 来实现摩拜单车「附近的 Mobike」、美团和饿了么「附近的餐馆」这样的功能了。

<br>

## **1. 用数据库来算附近的人**
- 当两个元素的距离不是很远时，可以直接使用勾股定理就能算得元素之间的距离。我们平时使用的「附近的人」的功能，元素距离都不是很大，勾股定理算距离足矣。

- 现在，如果要计算「附近的人」，也就是给定一个元素的坐标，然后计算这个坐标附近的其它元素，按照距离进行排序，该如何下手？

- 如果现在元素的经纬度坐标使用关系数据库（元素 id, 经度 x, 纬度 y）存储，你该如何计算？
    - 首先，你不可能通过遍历来计算所有的元素和目标元素的距离然后再进行排序，这个计算量太大了，性能指标肯定无法满足。

    - 一般的方法都是通过矩形区域来限定元素的数量，然后对区域内的元素进行全量距离计算再排序。这样可以明显减少计算量。划分矩形区域可以指定一个半径 r，使用一条 SQL 圈出来。当用户对筛出来的结果不满意，那就扩大半径继续筛选。

        ```sql
        select id from positions where x0-r < x < x0+r and y0-r < y < y0+r
        ```

    - 但是数据库查询性能毕竟有限，如果「附近的人」查询请求非常多，在高并发场合，这可能并不是一个很好的方案。

<br>

## **2. GeoHash 算法**
- **GeoHash 算法将```二维的经纬度```数据映射到```一维的整数```**，这样所有的元素都将在挂载到一条线上，**距离靠近的```二维坐标```映射到```一维后的点之间距离```也会很接近**。当我们想要计算「附近的人时」，首先将目标位置映射到这条线上，**然后在这个一维的线上获取附近的点就行了**。

- **GeoHash 算法会继续对这个整数做一次 ```base32``` 编码（0-9，a-z 去掉 a，i，l，o 四个字母）变成一个字符串**。在 Redis 里面，**经纬度使用 52 位的整数进行编码，放进了 zset 里面，zset 的 ```value``` 是```元素的 key```，```score``` 是 GeoHash 的 52 位```整数值```**。zset 的 score 虽然是浮点数，但是对于 52 位的整数值，它可以无损存储。

- 在使用 Redis 进行 Geo 查询时，我们要时刻想到它的内部结构实际上只是一个 ```zset（skiplist）```。通过 zset 的 score 排序就可以得到坐标附近的其它元素（实际情况要复杂一 些，不过这样理解足够了），通过将 score 还原成坐标值就可以得到元素的原始坐标。

<br>

## **3. Redis 的 Geo 指令基本使用**
- Redis 提供的 Geo 指令只有 6 个，读者们瞬间就可以掌握。使用时，读者务必再次想起，**它只是一个普通的 ```zset``` 结构**。

- **1. 增加**
    - **```geoadd``` 指令携带```集合名称```以及多个经```纬度名称三元组```**，注意这里可以加入多个三元组：
        ```bash
        127.0.0.1:6379> geoadd company 116.48105 39.996794 juejin 
        (integer) 1
        127.0.0.1:6379> geoadd company 116.514203 39.905409 ireader 
        (integer) 1
        127.0.0.1:6379> geoadd company 116.489033 40.007669 meituan
        (integer) 1
        127.0.0.1:6379> geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi 
        (integer) 2
        ```

    - 为什么 Redis 没有提供 geo 删除指令？反正它就是没有提供。

- **2. 距离**
    - **```geodist``` 指令可以用来计算两个元素之间的距离**，**携带```集合名称```、```2 个名称```和```距离单位```**。
        ```bash
        127.0.0.1:6379> geodist company juejin ireader km 
        "10.5501"
        127.0.0.1:6379> geodist company juejin meituan km 
        "1.3878"
        127.0.0.1:6379> geodist company juejin jd km 
        "24.2739"
        127.0.0.1:6379> geodist company juejin xiaomi km 
        "12.9606"
        127.0.0.1:6379> geodist company juejin juejin km 
        "0.0000"
        ```

    - 我们可以看到掘金离美团最近。距离单位可以是 m、km、ml、ft，分别代表米、千米、英里和尺。

- **3. 获取元素位置**
    - **```geopos``` 指令可以获取集合中任意元素的经纬度坐标**，可以一次获取多个。
        ```bash
        127.0.0.1:6379> geopos company juejin 
        1) 1) "116.48104995489120483"
            2) "39.99679348858259686"
        127.0.0.1:6379> geopos company ireader 
        1) 1) "116.5142020583152771"
            2) "39.90540918662494363" 
        127.0.0.1:6379> geopos company juejin ireader 
        1) 1) "116.48104995489120483"
            2) "39.99679348858259686" 
        2) 1) "116.5142020583152771"
            2) "39.90540918662494363"
        ```

    - **获取的经纬度坐标和 ```geoadd``` 进去的坐标有轻微的误差，原因是 ```geohash``` 对```二维坐标进行的一维映射是有损的```**，通过映射再还原回来的值会出现较小的差别。对于「附近的人」这种功能来说，这点误差根本不是事。

- **4. 获取元素的 hash 值**
    - **```geohash``` 可以获取元素的```经纬度编码字符串```**，上面已经提到，它是 ```base32``` 编码。

- **5. 附近的公司**
    - **```georadiusbymember``` 指令是最为关键的指令**，它可以用来**查询指定元素附近的其它元素**，它的参数非常复杂。
        ```bash
        # 范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身
        127.0.0.1:6379> georadiusbymember company ireader 20 km count 3 asc 
        1) "ireader"
        2) "juejin"
        3) "meituan"
        # 范围 20 公里以内最多 3 个元素按距离倒排
        127.0.0.1:6379> georadiusbymember company ireader 20 km count 3 desc 
        1) "jd"
        2) "meituan"
        3) "juejin"
        
        # 三个可选参数 withcoord withdist withhash 用来携带附加参数
        # withdist 很有用，它可以用来显示距离
        127.0.0.1:6379> georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc 
        1) 1) "ireader"
            2) "0.0000"
            3) (integer) 4069886008361398 
            4) 1) "116.5142020583152771"
                2) "39.90540918662494363" 
        2) 1) "juejin"
            2) "10.5501"
            3) (integer) 4069887154388167 
            4) 1) "116.48104995489120483"
                2) "39.99679348858259686" 
        3) 1) "meituan"
            2) "11.5748"
            3) (integer) 4069887179083478 
            4) 1) "116.48903220891952515"
                2) "40.00766997707732031"
        ```
    
    - **除了 ```georadiusbymember``` 指令```根据元素```查询附近的元素，Redis 还提供了```根据坐标值```来查询附近的元素**，这个指令更加有用，它可以根据用户的定位来计算「附近的车」，「附近 的餐馆」等。**它的参数和 ```georadiusbymember``` 基本一致，除了将目标元素改成```经纬度坐标值```**。
        ```bash
        127.0.0.1:6379> georadius company 116.514202 39.905409 20 km withdist count 3 asc 
        1) 1) "ireader"
            2) "0.0000" 
        2) 1) "juejin"
            2) "10.5501" 
        3) 1) "meituan"
            2) "11.5748"
        ```

<br>

## **4. 小结 & 注意事项**
- 在一个地图应用中，车的数据、餐馆的数据、人的数据可能会有百万千万条。
    - **如果使用 Redis 的 Geo 数据结构，它们将全部放在一个 ```zset``` 集合中**。在 Redis 的集群环境中，集合可能会从一个节点迁移到另一个节点，如果单个 key 的数据过大，会对集群的迁移工作造成较大的影响。
    
    - 在集群环境中单个 key 对应的数据量不宜超过 1M，否则会导致集群迁移出现卡顿现象，影响线上服务的正常运行。

- 所以，**这里建议 Geo 的数据使用```单独的 Redis 实例部署```，不使用集群环境**。

- 如果数据量过亿甚至更大，就需要对 Geo 数据进行拆分，按国家拆分、按省拆分，按市拆分，在人口特大城市甚至可以按区拆分。这样就可以显著降低单个 zset 集合的大小。