# **位图**

- **有一些 ```bool``` 型数据需要存取**，比如用户一年的签到记录，签了是 1，没签是 0，要记录 365 天。如果使用普通的 ```key/value```，每个用户要记录 365 个，当用户上亿的时候，需要的存储空间是惊人的。

- Redis 提供了位图数据结构，这样**每天的签到记录只占据一个位**，365 天就是 365 个位，46 个字节（一个稍长一点的字符串）就可以完全容纳下，这就大大节约了存储空间。

- Redis 位图 Bitmaps 不是实际的数据类型，**而是在字符串类型上定义的一组```面向位的操作```**。
    - 位图不是特殊的数据结构，**它的内容其实就是```普通的字符串```，也就是 ```byte``` 数组**。

    - 可以使用**普通的 ```get/set``` 直接获取和设置整个位图的内容**。

    - 也可以使用**位图操作 ```getbit/setbit``` 等将 ```byte``` 数组看成```「位数组」```来处理**。

    <img src="../images/bitmap.png" width="500" height="90" alt="bitmap" align=center/>

<br>

## **I. 基本使用**
### **1. SETBIT key offset value**
- **设置指定 ```key``` 的值在 ```offset``` 处的 ```bit``` 值，offset 从 0 开始**。

- **返回值为在 ```offset``` 处原来的 ```bit``` 值**。

- **Redis 的位数组是```自动扩展```**，如果设置了某个偏移位置超出了现有的内容范围，**就会自动将位数组进行零扩充**。

    ```bash
    # h 字符只有 1/2/4 位需要设置，e 字符只有 9/10/13/15 位需要设置。
    127.0.0.1:6379> setbit s 1 1 
    (integer) 0
    127.0.0.1:6379> setbit s 2 1 
    (integer) 0
    127.0.0.1:6379> setbit s 4 1 
    (integer) 0
    127.0.0.1:6379> setbit s 9 1 
    (integer) 0
    127.0.0.1:6379> setbit s 10 1 
    (integer) 0
    127.0.0.1:6379> setbit s 13 1 
    (integer) 0
    127.0.0.1:6379> setbit s 15 1 
    (integer) 0
    127.0.0.1:6379> get s
    "he"
    ```

- **上面这个例子可以理解为「```零存整取```」，同样我们还也可以「```零存零取```」，「```整存零取```」**。

    ```bash
    # 零存零取
    127.0.0.1:6379> setbit w 1 1 
    (integer) 0
    127.0.0.1:6379> setbit w 2 1 
    (integer) 0
    127.0.0.1:6379> setbit w 4 1 
    (integer) 0
    127.0.0.1:6379> getbit w 1 # 获取某个具体位置的值 0/1
    (integer) 1 
    127.0.0.1:6379> getbit w 2 
    (integer) 1 
    127.0.0.1:6379> getbit w 4 
    (integer) 1 
    127.0.0.1:6379> getbit w 5 
    (integer) 0
    ```

    ```bash
    # 整存零取
    127.0.0.1:6379> set w h # 整存 
    (integer) 0
    127.0.0.1:6379> getbit w 1 
    (integer) 1
    127.0.0.1:6379> getbit w 2 
    (integer) 1 
    127.0.0.1:6379> getbit w 4 
    (integer) 1 
    127.0.0.1:6379> getbit w 5 
    (integer) 0
    ```

- 如果对应位的字节是**不可打印字符**，```redis-cli``` 会显示该字符的 16 进制形式。

    ```bash
    127.0.0.1:6379> setbit x 0 1 
    (integer) 0
    127.0.0.1:6379> setbit x 1 1 
    (integer) 0
    127.0.0.1:6379> get x 
    "\xc0"
    ```

    ```bash
    # 通过位操作将 h 改成 i
    127.0.0.1:6379> SET h h         # 二进制为 01101000
    OK
    127.0.0.1:6379> SETBIT h 7 1    # 将最后一位改成1 => 01101001
    (integer) 0
    127.0.0.1:6379> GET h
    "i"
    ```

<br>

### **2. GETBIT key offset**
- **获取指定 ```key``` 的值在 ```offset``` 处的 ```bit``` 值，```offset``` 从 0 开始。如果 ```offset``` 超出了当前位图的范围，则返回 0**。

    ```bash
    127.0.0.1:6379> set i i       # 二进制为 01101001
    OK
    127.0.0.1:6379> getbit i 0    # 第1位为0
    (integer) 0
    127.0.0.1:6379> getbit i 1    # 第2位为0
    (integer) 1
    127.0.0.1:6379> getbit i 7    # 第8位为0
    (integer) 1
    ```

<br>

## **II. 统计和查找**
- **Redis 提供了位图统计指令 ```bitcount``` 和位图查找指令 ```bitpos```：**
    - **```bitcount``` 用来统计```指定位置范围内 1 的个数```**

    - **```bitpos``` 用来查找指定范围内出现的```第一个 0 或 1```**

### **1. BITCOUNT key [start end]**
- **统计指定 ```key``` 值中被```设置为 1 的 bit 数```**。可以通过指定参数 start 和 end 来限制统计范围。
    - 注意，**这里的 start 和 end 不是指 bit 的下标，而是字节（byte）的下标**。比如 start 为 1，则实际对应的 bit 下标为 8（1byte = 8 bit）

- **可以通过 ```bitcount``` 统计用户一共签到了多少天**。

    ```bash
    127.0.0.1:6379> set hi hi           # 二进制为 0110100001101001
    OK
    127.0.0.1:6379> bitcount hi         # 所有是1的位数：7个
    (integer) 7
    127.0.0.1:6379> bitcount hi 1 2     # 即统计 01101001 中1的位数
    (integer) 4
    ```

### **2. BITPOS key bit [start] [end]**
- **统计```首次出现的``` 0 或 1 的 bit 位**，可以通过 start 和 end 来指定范围，同样是指字节的下标。

- 在不存在的 key 或者空字符串中查找 1，则返回 -1。

- 在所有 bit 都为 1 中查找 bit 为 0 的情况下，返回字符串最右边的第一个空位。

- **通过 ```bitpos``` 指令查找用户从哪一天开始第一次签到**。**如果指定了范围参数 [```start, end```]，就可以统计在```某个时间范围内用户签到了多少天```，用户自某天以后的```哪天开始签到```**。

    ```bash
    127.0.0.1:6379> get nilkey           # 不存在的key    
    (nil)    
    127.0.0.1:6379> bitpos nilkey 1      # 在不存在的key中查首次出现1的位    
    (integer) -1    
    127.0.0.1:6379> setbit nilkey 0 0    # 空字符串    
    (integer) 0    
    127.0.0.1:6379> get nilkey    
    "\x00"    
    127.0.0.1:6379> bitpos nilkey 1    
    (integer) -1
    ```

### **3. BITOP operation destkey key [key …]**
- **对```一个或多个二进制位字符串```进行操作，并将结果保存到 ```destkey``` 上。当某个字符串长度不够时，对应的位用 0 补上**。

    - **AND（逻辑与）**：都为 1 返回 1，否则返回 0
        ```bash
        127.0.0.1:6379> set a a                  # 二进制  01100001    
        OK    
        127.0.0.1:6379> set c c                  # 二进制  01100011    
        OK    
        127.0.0.1:6379> bitop and destkey a c    # 与操作  01100001 -> a    
        (integer) 1    
        127.0.0.1:6379> get destkey    
        "a"
        ```

    - **OR（逻辑或）**：只要有一个 1 就返回 1，否则返回 0
        ```bash
        127.0.0.1:6379> set a a                 # 二进制  01100001    
        OK    
        127.0.0.1:6379> set b b                 # 二进制  01100010    
        OK    
        127.0.0.1:6379> bitop or destkey a b    # 或操作  01100011 -> c    
        (integer) 1    
        127.0.0.1:6379> get destkey    "c"      
        ```

    - **XOR（逻辑异或）**：当都是 0 或者都是 1 时返回 0，否则返回 1
        ```bash
        127.0.0.1:6379> set a a                 # 二进制  01100001    
        OK    
        127.0.0.1:6379> set z Z                 # 二进制  01011010 (大写的Z)    
        OK    
        127.0.0.1:6379> bitop xor destkey a z   # 异或    00111011 -> ; 分号    
        (integer) 1    
        127.0.0.1:6379> get destkey    
        ";"
        ```

    - **NOT（逻辑非）**：取反，1 变成 0，0 变成 1。只能传入一个要操作的 key
        ```bash
        01010101 -> 10101010
        ```

<br>

## **III. 场景实战**
- **需求：**
    - 实现**用户签到**

    - 统计今天所有的**签到数量**

    - 获取指定用户全年的**签到数**

    - 统计近 7 天**连续签到**的用户数量

    - 统计**本月全部签到**过的用户数量

    - 统计**近 7 天有过签到**的用户数量

- **使用位图的好处：**
    - **最直观的一点占用存储少**，1 个人 1 年的数据也就 365 bit，46 个字节；

    - **通过位运算操作多个字符串，效率高**；

- **演示:**
    - **每天的签到情况作为一条记录**，key 格式为 ```sign:{yyyyMMdd}```
    
    - **用户 ID 作为```偏移量```**

### **1. 用户签到**
- **将```用户 ID``` 作为偏移量，通过 ```setBit``` 设置该位置的值为 1**

### **2. 查询用户今天是否已经签到了**
- **将```用户 ID``` 作为偏移量，通过 ```getBit``` 查询该位置上的值是否为 1**

### **3. 统计今天所有的签到数量**
- 通过 ```bitCount``` 去实现统计

### **4. 统计指定用户全年的签到数**
- **Redis 中并没有提供对```多个二进制位字符串进行求和```操作**，我们需要自己去统计。思路：
    - 获取**本年所有签到记录的 key 列表**，即 ```sign:2020``` 开头的 key，可以通过 Redis 指令 ```keys sign:2020*``` 获取（**慎用 ```keys```**）

    - **遍历获取到的 key 列表，```统计已经签到过```的 key 的数量**

### **5. 统计近 7 天连续签到的用户数量**
- **对近 7 天的签到记录的进行```逻辑与```操作**，生成一个**连续七天签到的记录**

- **对生成的记录进行 ```bitCount```**

### **6. 统计近 7 天有过签到的用户数量**
- 和统计 7 天连续签到思路一样，只是这里使用**逻辑或**操作
















