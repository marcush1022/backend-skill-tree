# **持久化**

- **Redis 的数据全部在内存里，如果突然宕机，数据就会全部丢失**，因此必须有一种机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 **Redis 的持久化机制**。

- Redis 的持久化机制有 3 种
    - **`快照 (RDB)`、`AOF` 日志、`混合持久化`（redis4.0引入）**，。
    
    - **快照是一次`全量备份`，AOF 日志是连续的`增量备份`**。

    - **快照是内存数据的`二进制序列化`形式，在存储上非常紧凑**，
    
    - **而 AOF 日志记录的是`内存数据修改的指令记录文本`**。AOF 日志在长期的运行过程中会变的无比庞大，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫长。所以需要定期进行 AOF 重写，给 AOF 日志进行瘦身。

<br>

## **0. Redis 核心主流程**
- **`AOF` 和 `RDB` 的持久化过程中，有不少操作是在时间事件 `serverCron` 中被触发的**。所以，这边有必要先了解下 Redis 中的事件核心流程。
    - Redis 的服务器进程就是一个事件循环：
        - 最重要的有两个事件：**文件事件和时间事件**。
        
        - **Redis 在服务器初始化后，会无限循环，处理产生的文件事件和时间事件**。
    
    - 文件事件常见的有：**接受连接（accept）、读取（read）、写入（write）、关闭连接（close）等**。

    - 时间事件中常见的就是 `serverCron`，redis 核心流程中通常也只有这个时间事件。
        - `serverCron` 默认配置下每 100ms 会被触发一次
        
        - 在该时间事件中，会执行很多操作：**清理过期键、AOF 后台重写、RDB 的 save point 的检查、将 aof_buf 内容写到磁盘上（flushAppendOnlyFile 函数）等等**。

<br>

## **1. 快照原理 (RDB)**
- 我们知道 Redis 是单线程程序，这个线程要同时**负责多个客户端套接字的`并发读写操作`和`内存数据结构`的逻辑读写**。

- 在服务线上请求的同时，**Redis 还需要进行`内存快照`，内存快照要求 Redis 必须进行`文件 IO 操作`，可文件 IO 操作是不能使用`多路复用` API**。

    - **这意味着单线程同时在服务线上的请求还要进行文件 IO 操作**，文件 IO 操作会严重拖垮服务器请求的性能。
    
    - **还有个重要的问题是为了不阻塞线上的业务，就需要边持久化边响应客户端请求**。**持久化的同时，`内存数据结构`还在改变**，比如一个大型的 hash 字典正在持久化，结果一个请求过来把它给删掉了，还没持久化完呢，这尼玛要怎么搞？

- 那该怎么办呢?
    - **Redis 使用操作系统的`多进程 COW`（Copy On Write）机制来实现快照持久化**。

- 描述：**RDB 类似于快照。在某个时间点，将 Redis 在内存中的`数据库状态`（数据库的键值对等信息）保存到磁盘里面**。
    - **RDB 持久化功能生成的 RDB 文件是经过压缩的二进制文件**。

- 命令：有两个 Redis 命令可以用于生成 RDB 文件，一个是 `SAVE`，另一个是 `BGSAVE`。

    - `SAVE`：**生成 RDB 快照文件，但是会`阻塞`主进程**，服务器将无法处理客户端发来的命令请求，所以通常不会直接使用该命令。

    - `BGSAVE`：**fork 子进程来生成 RDB 快照文件，`阻塞`只会发生在 `fork` 子进程的时候**，之后主进程可以正常处理请求

- 开启：使用 `save point` 配置，**满足 `save point` 条件后会触发 `BGSAVE` 来存储一次快照**，这边的 `save point` 检查就是在上文提到的 `serverCron` 中进行。

    - save point 格式：save <seconds> <changes>，**含义是 Redis 如果在 seconds 秒内数据发生了 changes 次改变，就保存快照文件**。例如 Redis 默认就配置了以下3个：

        ```bash
        save 900 1 #900秒内有1个key发生了变化，则触发保存RDB文件
        save 300 10 #300秒内有10个key发生了变化，则触发保存RDB文件
        save 60 10000 #60秒内有10000个key发生了变化，则触发保存RDB文件
        ```

- 关闭：
    1. 注释掉所有 `save point` 配置可以关闭 RDB 持久化。
    
    2. 在所有 `save point` 配置后增加：`save ""`，该配置可以删除所有之前配置的 `save point`。

<br>

### **1.2. fork (多进程)**
- **Redis 在持久化时会调用 `glibc` 的函数 `fork` 产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求**。

- 子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。

- **这是 Linux 操作系统的机制，为了节约内存资源，所以尽可能让它们共享起来**。在进程分离的一瞬间，内存的增长几乎没有明显变化。

- 用 Python 语言描述进程分离的逻辑如下。fork 函数会在父子进程同时返回，在父进程里返回子进程的 pid，在子进程里返回零。如果操作系统内存资源不足，pid 就会是负数，表示 fork 失败。

    ```python
    pid = os.fork() 
    if pid > 0:
        handle_client_requests() # 父进程继续处理客户端请求
    if pid == 0:
        handle_snapshot_write() # 子进程处理快照写磁盘
    if pid < 0:
        # fork error
    ```

- 子进程做数据持久化，**它不会修改现有的内存数据结构**，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。

- 但是父进程不一样，**它必须持续服务客户端请求，然后对内存数据结构进行不间断的修改**。

- **这个时候就会使用操作系统的 `COW` 机制来进行数据段页面的分离**。数据段是由很多操作系统的页面组合而成，**当父进程对其中一个页面的数据进行修改时，会将`被共享的页面复制一份`分离出来，然后对这个复制的页面进行修改**。**这时子进程相应的页面是`没有变化`的，还是进程产生时那一瞬间的数据**。

- 随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的 2 倍大小。**另外一个 Redis 实例里冷数据占的比例往往是比较高的，所以很少会出现所有的页面都会被分离，被分离的往往只有其中一部分页面**。每个页面的大小只有 4K，一个 Redis 实例里面一般都会有成千上万的页面。

- **子进程因为`数据没有变化`，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化叫「快照」的原因**。接下来子进程就可以非常安心的遍历数据了进行序列化写磁盘了。

<br>

### **1.3. RDB 的优点**
1. **RDB 文件是是`经过压缩的二进制文件`，占用空间很小**，**它保存了 Redis `某个时间点`的数据集**，很适合用于做备份。

    - 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。

2. **RDB 非常适用于`灾难恢复`（disaster recovery）**：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心。

3. **RDB 可以最大化 redis 的性能**。**父进程在保存 RDB 文件时唯一要做的就是 `fork 出一个子进程`，然后这个子进程就会处理接下来的`所有保存工作`，父进程无须执行`任何磁盘 I/O 操作`**。

4. **RDB 在`恢复大数据集`时的速度比 AOF 的恢复速度要快**。

<br>

### **1.4. RDB 的缺点**
1. **RDB 在服务器故障时容易造成数据的丢失**。
    - RDB 允许我们通过修改 save point 配置来控制持久化的频率。但是，因为 RDB 文件需要保存整个数据集的状态， 所以它是一个比较重的操作，**如果频率太频繁，可能会对 Redis 性能产生影响**。
    
    - **所以通常可能设置`至少5分钟才保存一次快照`，这时如果 Redis 出现宕机等情况，则意味着`最多可能丢失5分钟数据`**。

2. **RDB 保存时使用 fork 子进程进行数据的持久化**
    - **`如果数据比较大的话，fork 可能会非常耗时`，造成 Redis 停止处理服务 N 毫秒**。如果数据集很大且 CPU 比较繁忙的时候，停止服务的时间甚至会到一秒。

3. **Linux fork 子进程采用的是 `copy-on-write` 的方式**。
    - 在 Redis 执行 RDB 持久化期间，如果 client 写入数据很频繁，那么将增加 Redis 占用的内存，最坏情况下，内存的占用将达到原先的2倍。

        - **刚 fork 时，主进程和子进程共享内存，但是随着主进程需要处理写操作，主进程`需要将修改的页面拷贝一份出来`，然后进行修改。极端情况下，如果`所有的页面都被修改`，则此时的内存占用是原先的2倍**。

<br>

## **2. AOF 原理**
- 描述：**保存 Redis 服务器所执行的所有写操作命令来记录数据库状态，并在服务器启动时，通过`重新执行这些命令`来还原数据集**。

- 开启：**`AOF` 持久化`默认是关闭`的，可以通过配置：`appendonly yes` 开启**。

- 关闭：**使用配置 `appendonly no` 可以关闭 `AOF` 持久化**。

- AOF 持久化功能的实现可以分为三个步骤：**命令追加、文件写入、文件同步**。
    - 命令追加：**当 AOF 持久化功能打开时，服务器在`执行完一个写命令之后`，会将被执行的写命令追加到服务器状态的 `aof 缓冲区`（aof_buf）的末尾**。

- 文件写入与文件同步：
    - 为什么将 `aof_buf` 的内容写到磁盘上需要两步操作：
        - **Linux 操作系统中为了提升性能，使用了页缓存（page cache）**。**当我们将 `aof_buf` 的内容写到磁盘上时，此时数据并没有真正的落盘，而是在 `page cache` 中**，为了将 page cache 中的数据真正落盘，**需要执行 `fsync / fdatasync` 命令来强制刷盘**。**这边的`文件同步`做的就是`刷盘操作`**，或者叫文件刷盘可能更容易理解一些。

        - 在文章开头，我们提过 serverCron 时间事件中会触发 `flushAppendOnlyFile` 函数，该函数会根据服务器配置的 `appendfsync` 参数值，来决定是否将 aof_buf 缓冲区的内容写入和保存到 AOF 文件。

<br>

### **2.1. AOF 的优点**
1. AOF 比 RDB可靠。**你可以设置不同的 fsync 策略：`no、everysec 和 always`**。
    
    - 默认是 everysec，在这种配置下，redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据。

2. **AOF 文件是一个`纯追加`的日志文件**。
    
    - **即使日志因为某些原因而包含了`未写入完整的命令`**（比如写入时磁盘已满，写入中途停机等等），我们也可以使用 redis-check-aof 工具也可以轻易地修复这种问题。

3. **当 AOF 文件太大时，Redis 会自动在后台进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合**。

    - 整个重写是绝对安全，**因为重写是在一个新的文件上进行**，同时 Redis 会继续往旧的文件追加数据。
    
    - **当新文件重写完毕，Redis 会把`新旧文件进行切换`，然后开始把数据写到新文件上**。

4. **AOF 文件有序地保存了对数据库执行的所有写入操作以 Redis 协议的格式保存，因此 AOF 文件的内容非常容易被人读懂**，对文件进行分析（parse）也很轻松。
    
    - 如果你不小心执行了 FLUSHALL 命令把所有数据刷掉了，但只要 AOF 文件没有被重写，那么只要停止服务器，移除 AOF 文件末尾的 FLUSHALL 命令，并重启 Redis，就可以将数据集恢复到 FLUSHALL 执行之前的状态。

<br>

### **2.2. AOF 的缺点**
1. **对于相同的数据集，AOF 文件的大小一般会比 RDB 文件大**。

2. **根据所使用的 fsync 策略，AOF 的速度可能会比 RDB 慢**。

    - 通常 fsync 设置为每秒一次就能获得比较高的性能，而关闭 fsync 可以让 AOF 的速度和 RDB 一样快。

<br>

## **3. 运维**
- **快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作**。 
    1. 遍历整个内存，大块写磁盘会加重系统负载。

    2. AOF 的 fsync 是一个耗时的 IO 操作，它会降低 Redis 性能，同时也会增加系统 IO 负担

- **所以通常 Redis 的`主节点`是不会进行持久化操作，持久化操作主要在`从节点`进行**。
    - 从节点是备份节点，**没有来自客户端请求的压力**，它的操作系统资源往往比较充沛。

- **但是如果出现`网络分区`，从节点长期连不上主节点**，就会出现数据不一致的问题，**特别是在网络分区出现的情况下又不小心`主节点宕机`了**，那么数据就会丢失，
    - **所以在生产环境要做好实时`监控`工作**，保证网络畅通或者能快速修复。
    
    - **另外还应该再`增加一个从节点`以降低网络分区的概率**，只要有一个从节点数据同步正常，数据也就不会轻易丢失。

<br>

## **4. Redis 4.0 混合持久化**
- 描述：混合持久化并不是一种全新的持久化方式，而是对已有方式的优化。
    - **混合持久化只发生于 `AOF 重写`过程**。
    
    - **使用了混合持久化，重写后的新 `AOF 文件`前半段是` RDB 格式的全量数据`，后半段是 `AOF 格式的增量数据`**。

- 重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。

- 我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实 例很大的情况下，启动需要花费很长的时间。

- **Redis 4.0 为了解决这个问题，带来了一个新的持久化选项：`混合持久化`**。
    - **将 `rdb 文件的内容`和`增量的 AOF 日志文件`存在一起**。
    
    - 这里的 AOF 日志不再是全量的日志，**而是`自持久化开始到持久化结束`的这段时间发生的`增量 AOF 日志`**，通常这部分 AOF 日志很小。

    - 于是在 Redis 重启的时候，**可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放**，重启效率因此大幅得到提升。