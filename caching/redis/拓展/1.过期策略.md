# **过期策略**

- 键的过期方式有两种：

    - **被动方式 - 惰性删除**
    
    - **主动方式 - 定期删除**

<br>

# **1. 惰性删除**
- **当客户端尝试访问 key 时，key 会被动过期**

    - 即 Redis 会检查该 key 是否设置了过期时间，如果过期了就会删除，也不会返回任何东西。

    - 注意并非是 key 到期了就会被自动删除，**而是当查询该 key 时，Redis 再很懒惰地检查是否删除**。

- 当然，这是不够的，因为有过期的 key，永远不会再访问。

<br>

# **2. 定期扫描删除**：
- **redis 默认每隔 100ms 就随机抽取一些`设置了过期时间`的 key，检查其`是否过期`，如果`有过期就删除`**。

- **过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的`贪心策略`**。

- **注意这里是`随机抽取`的**。假如 redis 存了几十万个 key ，每 100ms 遍历所有的设置过期时间的 key，会给 CPU 带来很大的负载。

    1. 从过期字典中随机 20 个 key；

    2. 删除这 20 个 key 中已经过期的 key；
    
    3. 如果过期的 key 比率超过 `1/4`，那就重复步骤 1；

- 同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，**算法还增加了扫描时间的上限，默认不会超过 `25ms`**。

- **设想一个大型的 Redis 实例中所有的 key 在`同一时间过期`了，会出现怎样的结果？**
    
    - **毫无疑问，Redis 会`持续扫描过期字典（循环多次）`，直到过期字典中过期的 `key 变得稀疏`，才会停止（循环次数明显下降）**。
    
    - 这就会导致**线上读写请求出现明显的卡顿现象**。导致这种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的 CPU 消耗。

    - 也许你会争辩说 “扫描不是有 25ms 的时间上限了么，怎么会导致卡顿呢”？这里打个 比方，假如有 101 个客户端同时将请求发过来了，然后前 100 个请求的执行时间都是 25ms，**那么第 101 个指令需要等待多久才能执行？2500ms，这个就是客户端的卡顿时间，是由服务器不间断的小卡顿积少成多导致的。**

    - **所以要注意过期时间，如果有`大批量的 key 过期`，要给过期时间设置一个`随机范围`，而不能全部在同一时间过期**。

        ```bash
        # 在目标过期时间上增加一天的随机时间
        redis.expire_at(key, random.randint(86400) + expire_ts)
        ```

<br>

# **3. 从库的过期策略**
- **从库不会进行过期扫描，从库对过期的处理是`被动`的**。

- 主库在 key 到期时，会在 `AOF` 文件里增加一条 `del` 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。

- **因为指令同步是`异步`进行的**

    - **所以`主库过期的 key 的 del 指令`没有及时同步到从库的话，会出现主从数据的不一致**，主库没有的数据在从库里还存在
    
    - 比如上一节的集群环境分布式锁的算法漏洞就是因为这个同步延迟产生的。